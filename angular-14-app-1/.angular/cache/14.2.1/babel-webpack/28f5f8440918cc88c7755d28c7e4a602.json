{
  "ast": null,
  "code": "import * as i0 from '@angular/core';\nimport { Injectable, Inject } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';\nimport { ɵBrowserPlatformLocation, DOCUMENT, PlatformLocation } from '@angular/common';\n\nfunction enableProdMode() {\n  try {\n    // The `enableProdMode` will throw an error if it's called multiple times,\n    // but it may be called multiple times when dependencies are shared.\n    i0.enableProdMode();\n  } catch (_a) {// Nothing to do here.\n  }\n}\n\nclass SingleSpaPlatformLocation extends ɵBrowserPlatformLocation {\n  constructor() {\n    super(...arguments); // This is a simple marker that helps us to ignore PopStateEvents\n    // that was not dispatched by the browser.\n\n    this.skipNextPopState = false;\n    this.source = 'Window.addEventListener:popstate';\n  }\n\n  pushState(state, title, url) {\n    this.skipNextPopState = true;\n    super.pushState(state, title, url);\n  }\n\n  replaceState(state, title, url) {\n    this.skipNextPopState = true;\n    super.replaceState(state, title, url);\n  }\n\n  onPopState(fn) {\n    // `Zone.current` will reference the zone that serves as an execution context\n    // to some specific application, especially when `onPopState` is called.\n    const zone = Zone.current; // Wrap any event listener into zone that is specific to some application.\n    // The main issue is `back/forward` buttons of browsers, because they invoke\n    // `history.back|forward` which dispatch `popstate` event. Since `single-spa`\n    // overrides `history.replaceState` Angular's zone cannot intercept this event.\n    // Only the root zone is able to intercept all events.\n    // See https://github.com/single-spa/single-spa-angular/issues/94 for more details\n\n    fn = zone.wrap(fn, this.source);\n\n    const onPopStateListener = event => {\n      // The `LocationChangeEvent` doesn't have the `singleSpa` property, since it's added\n      // by `single-spa` starting from `5.4` version. We need this check because we want\n      // to skip \"unnatural\" PopStateEvents, the one caused by `single-spa`.\n      const popStateEventWasDispatchedBySingleSpa = !!event.singleSpa;\n\n      if (this.skipNextPopState && popStateEventWasDispatchedBySingleSpa) {\n        this.skipNextPopState = false;\n      } else {\n        fn(event);\n      }\n    };\n\n    return super.onPopState(onPopStateListener);\n  }\n\n}\n\nSingleSpaPlatformLocation.ɵfac = /* @__PURE__ */function () {\n  let ɵSingleSpaPlatformLocation_BaseFactory;\n  return function SingleSpaPlatformLocation_Factory(t) {\n    return (ɵSingleSpaPlatformLocation_BaseFactory || (ɵSingleSpaPlatformLocation_BaseFactory = i0.ɵɵgetInheritedFactory(SingleSpaPlatformLocation)))(t || SingleSpaPlatformLocation);\n  };\n}();\n\nSingleSpaPlatformLocation.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SingleSpaPlatformLocation,\n  factory: SingleSpaPlatformLocation.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SingleSpaPlatformLocation, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * The `PlatformLocation` class is an \"injectee\" of the `PathLocationStrategy`,\n * which creates `Subject` internally for listening on `popstate` events. We want\n * to provide this class in the most top injector that's used during bootstrapping.\n */\n\n\nfunction getSingleSpaExtraProviders() {\n  return [{\n    provide: SingleSpaPlatformLocation,\n    deps: [[new Inject(DOCUMENT)]]\n  }, {\n    provide: PlatformLocation,\n    useExisting: SingleSpaPlatformLocation\n  }];\n}\n\nconst defaultOptions = {\n  // Required options that will be set by the library consumer.\n  NgZone: null,\n  bootstrapFunction: null,\n  template: null,\n  // Optional options\n  Router: undefined,\n  domElementGetter: undefined,\n  updateFunction: () => Promise.resolve(),\n  bootstrappedNgModuleRefOrAppRef: null\n};\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\n\nfunction singleSpaAngular(userOptions) {\n  if (NG_DEV_MODE && typeof userOptions !== 'object') {\n    throw Error('single-spa-angular requires a configuration object');\n  }\n\n  const options = Object.assign(Object.assign({}, defaultOptions), userOptions);\n\n  if (NG_DEV_MODE && typeof options.bootstrapFunction !== 'function') {\n    throw Error('single-spa-angular must be passed an options.bootstrapFunction');\n  }\n\n  if (NG_DEV_MODE && typeof options.template !== 'string') {\n    throw Error('single-spa-angular must be passed options.template string');\n  }\n\n  if (NG_DEV_MODE && !options.NgZone) {\n    throw Error(`single-spa-angular must be passed the NgZone option`);\n  }\n\n  if (NG_DEV_MODE && options.Router && !options.NavigationStart) {\n    // We call `console.warn` except of throwing `new Error()` since this will not\n    // be a breaking change.\n    console.warn(`single-spa-angular must be passed the NavigationStart option`);\n  }\n\n  return {\n    bootstrap: bootstrap.bind(null, options),\n    mount: mount.bind(null, options),\n    unmount: unmount.bind(null, options),\n    update: options.updateFunction\n  };\n}\n\nfunction bootstrap(options, props) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // Angular provides an opportunity to develop `zone-less` application, where developers\n    // have to trigger change detection manually.\n    // See https://angular.io/guide/zone#noopzone\n    if (options.NgZone === 'noop') {\n      return;\n    } // In order for multiple Angular apps to work concurrently on a page, they each need a unique identifier.\n\n\n    options.zoneIdentifier = `single-spa-angular:${props.name || props.appName}`; // This is a hack, since NgZone doesn't allow you to configure the property that identifies your zone.\n    // See https://github.com/PlaceMe-SAS/single-spa-angular-cli/issues/33,\n    // https://github.com/single-spa/single-spa-angular/issues/47,\n    // https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L144,\n    // and https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L257\n\n    options.NgZone.isInAngularZone = () => {\n      // @ts-ignore\n      return window.Zone.current._properties[options.zoneIdentifier] === true;\n    };\n\n    options.routingEventListener = () => {\n      options.bootstrappedNgZone.run(() => {// See https://github.com/single-spa/single-spa-angular/issues/86\n        // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work\n        // unless we tell Zone that something happened\n      });\n    };\n  });\n}\n\nfunction mount(options, props) {\n  return __awaiter(this, void 0, void 0, function* () {\n    getContainerElementAndSetTemplate(options, props);\n    const bootstrapPromise = options.bootstrapFunction(props);\n\n    if (NG_DEV_MODE && !(bootstrapPromise instanceof Promise)) {\n      throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);\n    }\n\n    const ngModuleRefOrAppRef = yield bootstrapPromise;\n\n    if (NG_DEV_MODE) {\n      if (!ngModuleRefOrAppRef || typeof ngModuleRefOrAppRef.destroy !== 'function') {\n        throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module or ApplicationRef. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);\n      }\n    }\n\n    const singleSpaPlatformLocation = ngModuleRefOrAppRef.injector.get(SingleSpaPlatformLocation, null);\n    const ngZoneEnabled = options.NgZone !== 'noop'; // The user has to provide `BrowserPlatformLocation` only if his application uses routing.\n    // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.\n    // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use\n    // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.\n\n    if (NG_DEV_MODE && ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {\n      throw new Error(`\n      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?\n    `);\n    }\n\n    const bootstrappedOptions = options;\n\n    if (ngZoneEnabled) {\n      const ngZone = ngModuleRefOrAppRef.injector.get(options.NgZone);\n      const zoneIdentifier = bootstrappedOptions.zoneIdentifier; // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`\n      // function was not called.\n\n      if (singleSpaPlatformLocation !== null) {\n        skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options);\n      }\n\n      bootstrappedOptions.bootstrappedNgZone = ngZone;\n      bootstrappedOptions.bootstrappedNgZone['_inner']._properties[zoneIdentifier] = true;\n      window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);\n    }\n\n    bootstrappedOptions.bootstrappedNgModuleRefOrAppRef = ngModuleRefOrAppRef;\n    return ngModuleRefOrAppRef;\n  });\n}\n\nfunction unmount(options) {\n  return Promise.resolve().then(() => {\n    if (options.routingEventListener) {\n      window.removeEventListener('single-spa:routing-event', options.routingEventListener);\n    }\n\n    options.bootstrappedNgModuleRefOrAppRef.destroy();\n    options.bootstrappedNgModuleRefOrAppRef = null;\n  });\n}\n\nfunction skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options) {\n  if (!options.NavigationStart) {\n    // As discussed we don't do anything right now if the developer doesn't provide\n    // `options.NavigationStart` since this might be a breaking change.\n    return;\n  }\n\n  const router = ngModuleRefOrAppRef.injector.get(options.Router);\n  const subscription = router.events.subscribe(event => {\n    if (event instanceof options.NavigationStart) {\n      const currentNavigation = router.getCurrentNavigation(); // This listener will be set up for each Angular application\n      // that has routing capabilities.\n      // We set `skipLocationChange` for each non-imperative navigation,\n      // Angular router checks under the hood if it has to change\n      // the browser URL or not.\n      // If `skipLocationChange` is truthy then Angular router will not call\n      // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.\n\n      if (currentNavigation.trigger !== 'imperative') {\n        currentNavigation.extras.skipLocationChange = true;\n        currentNavigation.extras.replaceUrl = false;\n      }\n    }\n  }); // The `ApplicationRef` also has `onDestroy` method, but it's marked as internal.\n\n  ngModuleRefOrAppRef['onDestroy'](() => {\n    subscription.unsubscribe();\n  });\n}\n/**\n * The public api for consumers of single-spa-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { enableProdMode, getSingleSpaExtraProviders, singleSpaAngular };",
  "map": {
    "version": 3,
    "names": [
      "i0",
      "Injectable",
      "Inject",
      "__awaiter",
      "getContainerElementAndSetTemplate",
      "ɵBrowserPlatformLocation",
      "DOCUMENT",
      "PlatformLocation",
      "enableProdMode",
      "_a",
      "SingleSpaPlatformLocation",
      "constructor",
      "arguments",
      "skipNextPopState",
      "source",
      "pushState",
      "state",
      "title",
      "url",
      "replaceState",
      "onPopState",
      "fn",
      "zone",
      "Zone",
      "current",
      "wrap",
      "onPopStateListener",
      "event",
      "popStateEventWasDispatchedBySingleSpa",
      "singleSpa",
      "ɵfac",
      "ɵprov",
      "type",
      "getSingleSpaExtraProviders",
      "provide",
      "deps",
      "useExisting",
      "defaultOptions",
      "NgZone",
      "bootstrapFunction",
      "template",
      "Router",
      "undefined",
      "domElementGetter",
      "updateFunction",
      "Promise",
      "resolve",
      "bootstrappedNgModuleRefOrAppRef",
      "NG_DEV_MODE",
      "ngDevMode",
      "singleSpaAngular",
      "userOptions",
      "Error",
      "options",
      "Object",
      "assign",
      "NavigationStart",
      "console",
      "warn",
      "bootstrap",
      "bind",
      "mount",
      "unmount",
      "update",
      "props",
      "zoneIdentifier",
      "name",
      "appName",
      "isInAngularZone",
      "window",
      "_properties",
      "routingEventListener",
      "bootstrappedNgZone",
      "run",
      "bootstrapPromise",
      "ngModuleRefOrAppRef",
      "destroy",
      "singleSpaPlatformLocation",
      "injector",
      "get",
      "ngZoneEnabled",
      "bootstrappedOptions",
      "ngZone",
      "skipLocationChangeOnNonImperativeRoutingTriggers",
      "addEventListener",
      "then",
      "removeEventListener",
      "router",
      "subscription",
      "events",
      "subscribe",
      "currentNavigation",
      "getCurrentNavigation",
      "trigger",
      "extras",
      "skipLocationChange",
      "replaceUrl",
      "unsubscribe"
    ],
    "sources": [
      "/home/nelson/Repos/bradesco-app/angular-14-app-1/node_modules/single-spa-angular/fesm2015/single-spa-angular.mjs"
    ],
    "sourcesContent": [
      "import * as i0 from '@angular/core';\nimport { Injectable, Inject } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';\nimport { ɵBrowserPlatformLocation, DOCUMENT, PlatformLocation } from '@angular/common';\n\nfunction enableProdMode() {\n    try {\n        // The `enableProdMode` will throw an error if it's called multiple times,\n        // but it may be called multiple times when dependencies are shared.\n        i0.enableProdMode();\n    }\n    catch (_a) {\n        // Nothing to do here.\n    }\n}\n\nclass SingleSpaPlatformLocation extends ɵBrowserPlatformLocation {\n    constructor() {\n        super(...arguments);\n        // This is a simple marker that helps us to ignore PopStateEvents\n        // that was not dispatched by the browser.\n        this.skipNextPopState = false;\n        this.source = 'Window.addEventListener:popstate';\n    }\n    pushState(state, title, url) {\n        this.skipNextPopState = true;\n        super.pushState(state, title, url);\n    }\n    replaceState(state, title, url) {\n        this.skipNextPopState = true;\n        super.replaceState(state, title, url);\n    }\n    onPopState(fn) {\n        // `Zone.current` will reference the zone that serves as an execution context\n        // to some specific application, especially when `onPopState` is called.\n        const zone = Zone.current;\n        // Wrap any event listener into zone that is specific to some application.\n        // The main issue is `back/forward` buttons of browsers, because they invoke\n        // `history.back|forward` which dispatch `popstate` event. Since `single-spa`\n        // overrides `history.replaceState` Angular's zone cannot intercept this event.\n        // Only the root zone is able to intercept all events.\n        // See https://github.com/single-spa/single-spa-angular/issues/94 for more details\n        fn = zone.wrap(fn, this.source);\n        const onPopStateListener = (event) => {\n            // The `LocationChangeEvent` doesn't have the `singleSpa` property, since it's added\n            // by `single-spa` starting from `5.4` version. We need this check because we want\n            // to skip \"unnatural\" PopStateEvents, the one caused by `single-spa`.\n            const popStateEventWasDispatchedBySingleSpa = !!event\n                .singleSpa;\n            if (this.skipNextPopState && popStateEventWasDispatchedBySingleSpa) {\n                this.skipNextPopState = false;\n            }\n            else {\n                fn(event);\n            }\n        };\n        return super.onPopState(onPopStateListener);\n    }\n}\nSingleSpaPlatformLocation.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: SingleSpaPlatformLocation, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\nSingleSpaPlatformLocation.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: SingleSpaPlatformLocation });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: SingleSpaPlatformLocation, decorators: [{\n            type: Injectable\n        }] });\n/**\n * The `PlatformLocation` class is an \"injectee\" of the `PathLocationStrategy`,\n * which creates `Subject` internally for listening on `popstate` events. We want\n * to provide this class in the most top injector that's used during bootstrapping.\n */\nfunction getSingleSpaExtraProviders() {\n    return [\n        {\n            provide: SingleSpaPlatformLocation,\n            deps: [[new Inject(DOCUMENT)]],\n        },\n        {\n            provide: PlatformLocation,\n            useExisting: SingleSpaPlatformLocation,\n        },\n    ];\n}\n\nconst defaultOptions = {\n    // Required options that will be set by the library consumer.\n    NgZone: null,\n    bootstrapFunction: null,\n    template: null,\n    // Optional options\n    Router: undefined,\n    domElementGetter: undefined,\n    updateFunction: () => Promise.resolve(),\n    bootstrappedNgModuleRefOrAppRef: null,\n};\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\nfunction singleSpaAngular(userOptions) {\n    if (NG_DEV_MODE && typeof userOptions !== 'object') {\n        throw Error('single-spa-angular requires a configuration object');\n    }\n    const options = Object.assign(Object.assign({}, defaultOptions), userOptions);\n    if (NG_DEV_MODE && typeof options.bootstrapFunction !== 'function') {\n        throw Error('single-spa-angular must be passed an options.bootstrapFunction');\n    }\n    if (NG_DEV_MODE && typeof options.template !== 'string') {\n        throw Error('single-spa-angular must be passed options.template string');\n    }\n    if (NG_DEV_MODE && !options.NgZone) {\n        throw Error(`single-spa-angular must be passed the NgZone option`);\n    }\n    if (NG_DEV_MODE && options.Router && !options.NavigationStart) {\n        // We call `console.warn` except of throwing `new Error()` since this will not\n        // be a breaking change.\n        console.warn(`single-spa-angular must be passed the NavigationStart option`);\n    }\n    return {\n        bootstrap: bootstrap.bind(null, options),\n        mount: mount.bind(null, options),\n        unmount: unmount.bind(null, options),\n        update: options.updateFunction,\n    };\n}\nfunction bootstrap(options, props) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Angular provides an opportunity to develop `zone-less` application, where developers\n        // have to trigger change detection manually.\n        // See https://angular.io/guide/zone#noopzone\n        if (options.NgZone === 'noop') {\n            return;\n        }\n        // In order for multiple Angular apps to work concurrently on a page, they each need a unique identifier.\n        options.zoneIdentifier = `single-spa-angular:${props.name || props.appName}`;\n        // This is a hack, since NgZone doesn't allow you to configure the property that identifies your zone.\n        // See https://github.com/PlaceMe-SAS/single-spa-angular-cli/issues/33,\n        // https://github.com/single-spa/single-spa-angular/issues/47,\n        // https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L144,\n        // and https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L257\n        options.NgZone.isInAngularZone = () => {\n            // @ts-ignore\n            return window.Zone.current._properties[options.zoneIdentifier] === true;\n        };\n        options.routingEventListener = () => {\n            options.bootstrappedNgZone.run(() => {\n                // See https://github.com/single-spa/single-spa-angular/issues/86\n                // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work\n                // unless we tell Zone that something happened\n            });\n        };\n    });\n}\nfunction mount(options, props) {\n    return __awaiter(this, void 0, void 0, function* () {\n        getContainerElementAndSetTemplate(options, props);\n        const bootstrapPromise = options.bootstrapFunction(props);\n        if (NG_DEV_MODE && !(bootstrapPromise instanceof Promise)) {\n            throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);\n        }\n        const ngModuleRefOrAppRef = yield bootstrapPromise;\n        if (NG_DEV_MODE) {\n            if (!ngModuleRefOrAppRef || typeof ngModuleRefOrAppRef.destroy !== 'function') {\n                throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module or ApplicationRef. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);\n            }\n        }\n        const singleSpaPlatformLocation = ngModuleRefOrAppRef.injector.get(SingleSpaPlatformLocation, null);\n        const ngZoneEnabled = options.NgZone !== 'noop';\n        // The user has to provide `BrowserPlatformLocation` only if his application uses routing.\n        // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.\n        // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use\n        // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.\n        if (NG_DEV_MODE && ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {\n            throw new Error(`\n      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?\n    `);\n        }\n        const bootstrappedOptions = options;\n        if (ngZoneEnabled) {\n            const ngZone = ngModuleRefOrAppRef.injector.get(options.NgZone);\n            const zoneIdentifier = bootstrappedOptions.zoneIdentifier;\n            // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`\n            // function was not called.\n            if (singleSpaPlatformLocation !== null) {\n                skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options);\n            }\n            bootstrappedOptions.bootstrappedNgZone = ngZone;\n            bootstrappedOptions.bootstrappedNgZone['_inner']._properties[zoneIdentifier] = true;\n            window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);\n        }\n        bootstrappedOptions.bootstrappedNgModuleRefOrAppRef = ngModuleRefOrAppRef;\n        return ngModuleRefOrAppRef;\n    });\n}\nfunction unmount(options) {\n    return Promise.resolve().then(() => {\n        if (options.routingEventListener) {\n            window.removeEventListener('single-spa:routing-event', options.routingEventListener);\n        }\n        options.bootstrappedNgModuleRefOrAppRef.destroy();\n        options.bootstrappedNgModuleRefOrAppRef = null;\n    });\n}\nfunction skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options) {\n    if (!options.NavigationStart) {\n        // As discussed we don't do anything right now if the developer doesn't provide\n        // `options.NavigationStart` since this might be a breaking change.\n        return;\n    }\n    const router = ngModuleRefOrAppRef.injector.get(options.Router);\n    const subscription = router.events.subscribe((event) => {\n        if (event instanceof options.NavigationStart) {\n            const currentNavigation = router.getCurrentNavigation();\n            // This listener will be set up for each Angular application\n            // that has routing capabilities.\n            // We set `skipLocationChange` for each non-imperative navigation,\n            // Angular router checks under the hood if it has to change\n            // the browser URL or not.\n            // If `skipLocationChange` is truthy then Angular router will not call\n            // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.\n            if (currentNavigation.trigger !== 'imperative') {\n                currentNavigation.extras.skipLocationChange = true;\n                currentNavigation.extras.replaceUrl = false;\n            }\n        }\n    });\n    // The `ApplicationRef` also has `onDestroy` method, but it's marked as internal.\n    ngModuleRefOrAppRef['onDestroy'](() => {\n        subscription.unsubscribe();\n    });\n}\n\n/**\n * The public api for consumers of single-spa-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { enableProdMode, getSingleSpaExtraProviders, singleSpaAngular };\n"
    ],
    "mappings": "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"
  },
  "metadata": {},
  "sourceType": "module"
}
